{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Strawberry Graphql Auth \u00b6 JWT Authentication / Authorization system for strawberry-django. Demo \u00b6 About \u00b6 Abstract all the basic logic of handling user accounts out of your app, so you don't need to think about it and can get you up and running faster . No lock-in. When you are ready to implement your own code or this package is not up to your expectations , it's easy to extend or switch to your implementation . Features \u00b6 Awesome docs! Captcha validation Async/Sync supported! Works with default or custom user model JWT authentication (with Strawberry Django JWT ) User registration with email verification Add secondary email, with email verification too Resend activation email Retrieve/Update user Archive user Permanently delete user or make it inactive Turn archived user active again on login Track user status (archived, verified, secondary email) Password change Password reset through email Revoke user tokens on account archive/delete/password change/reset All mutations return success and errors Default email templates (you will customize though) Customizable, no lock-in Passwordless registration You can now jump to the Tutorial .","title":"Start here"},{"location":"#strawberry-graphql-auth","text":"JWT Authentication / Authorization system for strawberry-django.","title":"Strawberry Graphql Auth"},{"location":"#demo","text":"","title":"Demo"},{"location":"#about","text":"Abstract all the basic logic of handling user accounts out of your app, so you don't need to think about it and can get you up and running faster . No lock-in. When you are ready to implement your own code or this package is not up to your expectations , it's easy to extend or switch to your implementation .","title":"About"},{"location":"#features","text":"Awesome docs! Captcha validation Async/Sync supported! Works with default or custom user model JWT authentication (with Strawberry Django JWT ) User registration with email verification Add secondary email, with email verification too Resend activation email Retrieve/Update user Archive user Permanently delete user or make it inactive Turn archived user active again on login Track user status (archived, verified, secondary email) Password change Password reset through email Revoke user tokens on account archive/delete/password change/reset All mutations return success and errors Default email templates (you will customize though) Customizable, no lock-in Passwordless registration You can now jump to the Tutorial .","title":"Features"},{"location":"api/","text":"auto generated using pydoc_markdown Captcha \u00b6 class Captcha () Creates a brand-new captcha. Returns a base64 encoded string of the captcha. And uuid representing the captcha id in the database. When you will try to log in or register You will need submit that uuid With the user input. The captcha will be invoked when the timeout expires . RegisterMixin \u00b6 class RegisterMixin ( BaseMixin ) Register user with fields defined in the settings. If the email field of the user model is part of the registration fields (default), check if there is no user with that email. If it exists, it does not register the user, even if the email field is not defined as unique (default of the default django user model). When creating the user, it also creates a UserStatus related to that user, making it possible to track if the user is archived / verified. Send account verification email. If allowed to not verified users login, return token. VerifyAccountMixin \u00b6 class VerifyAccountMixin ( BaseMixin ) Verify user account. Receive the token that was sent by email. If the token is valid, make the user verified by making the user.status.verified field true. ResendActivationEmailMixin \u00b6 class ResendActivationEmailMixin ( BaseMixin ) Sends activation email. It is called resend because theoretically the first activation email was sent when the user registered. If there is no user with the requested email, a successful response is returned. SendPasswordResetEmailMixin \u00b6 class SendPasswordResetEmailMixin ( BaseMixin ) Send password reset email. For non verified users, send an activation email instead. If there is no user with the requested email, a successful response is returned. PasswordResetMixin \u00b6 class PasswordResetMixin ( BaseMixin ) Change user password without old password. Receive the token that was sent by email. If token and new passwords are valid, update user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it. PasswordSetMixin \u00b6 class PasswordSetMixin ( BaseMixin ) Set user password - for password-less registration Receive the token that was sent by email. If token and new passwords are valid, set user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it. ObtainJSONWebTokenMixin \u00b6 class ObtainJSONWebTokenMixin ( BaseMixin ) Obtain JSON web token for given user. Allow to perform login with different fields, The fields are defined on settings. Not verified users can log in by default. This can be changes on settings. If user is archived, make it unarchived and return unarchiving=True on OutputBase. ArchiveAccountMixin \u00b6 class ArchiveAccountMixin ( ArchiveOrDeleteMixin ) Archive account and revoke refresh tokens. User must be verified and confirm password. DeleteAccountMixin \u00b6 class DeleteAccountMixin ( ArchiveOrDeleteMixin ) Delete account permanently or make user.is_active=False . The behavior is defined on settings. Anyway user refresh tokens are revoked. User must be verified and confirm password. PasswordChangeMixin \u00b6 class PasswordChangeMixin ( BaseMixin ) Change account password when user knows the old password. A new token and refresh token are sent. User must be verified. UpdateAccountMixin \u00b6 class UpdateAccountMixin ( BaseMixin ) Update user model fields, defined on settings. User must be verified. VerifyTokenMixin \u00b6 class VerifyTokenMixin ( BaseMixin ) Checks if a token is not expired and correct. \u00b6 Note that this is not for refresh tokens. RefreshTokenMixin \u00b6 class RefreshTokenMixin ( BaseMixin ) refreshToken to generate a new login token: \u00b6 Use this only if JWT_LONG_RUNNING_REFRESH_TOKEN is True using the refresh-token you already got during authorization, and obtain a brand-new token (and possibly a new refresh token if you revoked the previous). This is an alternative to log in when your token expired. RevokeTokenMixin \u00b6 class RevokeTokenMixin ( BaseMixin ) Suspends a refresh token. \u00b6 token must exist to be revoked.","title":"API"},{"location":"api/#captcha","text":"class Captcha () Creates a brand-new captcha. Returns a base64 encoded string of the captcha. And uuid representing the captcha id in the database. When you will try to log in or register You will need submit that uuid With the user input. The captcha will be invoked when the timeout expires .","title":"Captcha"},{"location":"api/#registermixin","text":"class RegisterMixin ( BaseMixin ) Register user with fields defined in the settings. If the email field of the user model is part of the registration fields (default), check if there is no user with that email. If it exists, it does not register the user, even if the email field is not defined as unique (default of the default django user model). When creating the user, it also creates a UserStatus related to that user, making it possible to track if the user is archived / verified. Send account verification email. If allowed to not verified users login, return token.","title":"RegisterMixin"},{"location":"api/#verifyaccountmixin","text":"class VerifyAccountMixin ( BaseMixin ) Verify user account. Receive the token that was sent by email. If the token is valid, make the user verified by making the user.status.verified field true.","title":"VerifyAccountMixin"},{"location":"api/#resendactivationemailmixin","text":"class ResendActivationEmailMixin ( BaseMixin ) Sends activation email. It is called resend because theoretically the first activation email was sent when the user registered. If there is no user with the requested email, a successful response is returned.","title":"ResendActivationEmailMixin"},{"location":"api/#sendpasswordresetemailmixin","text":"class SendPasswordResetEmailMixin ( BaseMixin ) Send password reset email. For non verified users, send an activation email instead. If there is no user with the requested email, a successful response is returned.","title":"SendPasswordResetEmailMixin"},{"location":"api/#passwordresetmixin","text":"class PasswordResetMixin ( BaseMixin ) Change user password without old password. Receive the token that was sent by email. If token and new passwords are valid, update user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it.","title":"PasswordResetMixin"},{"location":"api/#passwordsetmixin","text":"class PasswordSetMixin ( BaseMixin ) Set user password - for password-less registration Receive the token that was sent by email. If token and new passwords are valid, set user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it.","title":"PasswordSetMixin"},{"location":"api/#obtainjsonwebtokenmixin","text":"class ObtainJSONWebTokenMixin ( BaseMixin ) Obtain JSON web token for given user. Allow to perform login with different fields, The fields are defined on settings. Not verified users can log in by default. This can be changes on settings. If user is archived, make it unarchived and return unarchiving=True on OutputBase.","title":"ObtainJSONWebTokenMixin"},{"location":"api/#archiveaccountmixin","text":"class ArchiveAccountMixin ( ArchiveOrDeleteMixin ) Archive account and revoke refresh tokens. User must be verified and confirm password.","title":"ArchiveAccountMixin"},{"location":"api/#deleteaccountmixin","text":"class DeleteAccountMixin ( ArchiveOrDeleteMixin ) Delete account permanently or make user.is_active=False . The behavior is defined on settings. Anyway user refresh tokens are revoked. User must be verified and confirm password.","title":"DeleteAccountMixin"},{"location":"api/#passwordchangemixin","text":"class PasswordChangeMixin ( BaseMixin ) Change account password when user knows the old password. A new token and refresh token are sent. User must be verified.","title":"PasswordChangeMixin"},{"location":"api/#updateaccountmixin","text":"class UpdateAccountMixin ( BaseMixin ) Update user model fields, defined on settings. User must be verified.","title":"UpdateAccountMixin"},{"location":"api/#verifytokenmixin","text":"class VerifyTokenMixin ( BaseMixin )","title":"VerifyTokenMixin"},{"location":"api/#checks-if-a-token-is-not-expired-and-correct","text":"Note that this is not for refresh tokens.","title":"Checks if a token is not expired and correct."},{"location":"api/#refreshtokenmixin","text":"class RefreshTokenMixin ( BaseMixin )","title":"RefreshTokenMixin"},{"location":"api/#refreshtoken-to-generate-a-new-login-token","text":"Use this only if JWT_LONG_RUNNING_REFRESH_TOKEN is True using the refresh-token you already got during authorization, and obtain a brand-new token (and possibly a new refresh token if you revoked the previous). This is an alternative to log in when your token expired.","title":"refreshToken to generate a new login token:"},{"location":"api/#revoketokenmixin","text":"class RevokeTokenMixin ( BaseMixin )","title":"RevokeTokenMixin"},{"location":"api/#suspends-a-refresh-token","text":"token must exist to be revoked.","title":"Suspends a refresh token."},{"location":"captcha/","text":"Captcha \u00b6 this package provides a fully functional captcha validation system the default setting are: LOGIN_REQUIRE_CAPTCHA = True , REGISTER_REQUIRE_CAPTCHA = True , if you don't like this set them to False. The Captcha is available to query via a base64 encoded string or via a static .png image. Note: The Image is in PNG format base64 static mutation MyMutation { captcha { uuid pilImage } } You will further be needed to implement a translation in the UI. For the creation of a static set CAPTCHA_SAVE_IMAGE = True on your settings. This will use django's Imagefield to store the captcha image. You will also be needed to include a path in your urlpatterns for development, as per the documentation . mutation MyMutation { captcha { uuid image{ width height url } } }","title":"Captcha"},{"location":"captcha/#captcha","text":"this package provides a fully functional captcha validation system the default setting are: LOGIN_REQUIRE_CAPTCHA = True , REGISTER_REQUIRE_CAPTCHA = True , if you don't like this set them to False. The Captcha is available to query via a base64 encoded string or via a static .png image. Note: The Image is in PNG format base64 static mutation MyMutation { captcha { uuid pilImage } } You will further be needed to implement a translation in the UI. For the creation of a static set CAPTCHA_SAVE_IMAGE = True on your settings. This will use django's Imagefield to store the captcha image. You will also be needed to include a path in your urlpatterns for development, as per the documentation . mutation MyMutation { captcha { uuid image{ width height url } } }","title":"Captcha"},{"location":"changelog/","text":"Changelog \u00b6 v0.3.6.0 \u00b6 Deprecations: \u00b6 Removed secondary email support. New features \u00b6 - mypy support \u00b6 v0.3.5.1 \u00b6 New features \u00b6 Support for subscriptions, tested with channels integrations. v0.3.5.0 \u00b6 New features: \u00b6 new setting GqlAuthSettings.JWT_TOKEN_FINDER for finding the token from Info object, useful for integrations that provide custom info object. v0.3.4.2 \u00b6 Deprecations: \u00b6 users query was removed due to security concerns. If you want it implement it yourself and make sure to use the appropriate auth measures SomeField.afield is removed, and you can use now just SomeField.field for async/sync. decorators are deprecated, and you should use directives from now on. New features: \u00b6 v0.3.4.1 \u00b6 deprecations \u00b6 LOGIN_REQUIRED_FIELDS and LOGIN_OPTIONAL_FIELDS are deprecated in favor of LOGIN_FIELDS . From now on you should pass StrawberryField instance to LOGIN_FIELDS and it is absolutely your responsibility what would be optional/required. REGISTER_MUTATION_FIELDS_OPTIONAL is deprecated in favor of REGISTER_MUTATION_FIELDS . UPDATE_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS are also taking StrawberryField instances from now on. v0.3.4.0 \u00b6 New features serve Captcha over static files. New setting introduced, CAPTCHA_SAVE_IMAGE: bool = False . v0.3.3.2 \u00b6 New features Any fields that are in either UPDATE_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS_OPTIONAL And the pk field of the model. Will be inserted to UserType and will be in user queries. Doc strings in gqlquth_settings object Bug fixed Issue #45, #42 LOGIN_REQUIRED_FIELDS is now supported,\\ These fields would be used to authenticate with SD-jwt authenticate function. This function will call each of our AUTHENTICATION_BACKENDS , And will return the user from one of them unless PermissionDenied was raised. REGISTER_MUTATION_FIELDS is now supported,\\ Fields that will be registered there will be required by Register mutation Development Notes Added new marker for pytest, default_user this is the user defined in the default settings, And the custom user is in settings_b.py with no email field. v0.3.3.1 - pre-release \u00b6 New features async support using ASGI, the resolvers are still sync because of django's ORM - API changes Previously, following the graphene version, we did i.e token_auth = relay.ObtainJSONWebToken.Field ,\\ In order to respect pep8 (since it is a function)\\ and Strawberry style we changed it to token_auth = relay.ObtainJSONWebToken.field . Renamed Cap.Field to Captcha.field . Deprecations Removed setting ASYNC_EMAIL_TASK, (originally this was a celery task). Development Notes Major refactoring of how the test work: removed all the dicts that was flying around and used dataclasses. added async tests for all tests. no longer using request factory, now using test client as it emulates more real life environment. v0.3.16 \u00b6 Nothing new, adding PyJWT<=2.0.0 to requirements v0.3.15 \u00b6 Emit user_verified signal on password reset (thanks to @imsheldon ) v0.3.14 \u00b6 Add passwordless registration (thanks to @joshuachinemezu ) Add user_verified and user_registered signals (thanks to @mnieber ) Verify user in password reset mutation (thanks to capaci ) v0.3.13 \u00b6 Add EMAIL_TEMPLATE_VARIABLES setting (thanks to capaci ) v0.3.12 \u00b6 Add CUSTOM_ERROR_TYPE setting (thanks to boolangery ) v0.3.11 \u00b6 Add select_related to UserNode to limit db queries (thanks to maxpeterson ) v0.3.10 \u00b6 Pseudo async email support (thanks to bzhr and me ) v0.3.9 \u00b6 Prevents that UserNode is registered globally for the User type (thanks to panosangelopoulos ) v0.3.8 \u00b6 Add request and timestamp to email templates (thanks to yanivtoledano ) v0.3.7 \u00b6 Add template variables to email subjects. v0.3.6 \u00b6 Replace RemovedInDjango40Warning ugettext with gettext (thanks to ulgens ) v0.3.5 \u00b6 Added MeQuery (thanks to pors ). v0.3.4 \u00b6 Renamed from ErrorType to ExpectedErrorType , preventing clash with a strawberry.django type with same name.. v0.3.3 \u00b6 Fixed bug when performing login in PasswordChangeMixin (thanks to panosangelopoulos ). v0.3.2 \u00b6 Fixed typo in error code/message for expired_token (thanks to yanivtoledano ). v0.3.1 \u00b6 add pk to UserNode. v0.3.0 \u00b6 release beta. v0.2 \u00b6 v0.2.8 \u00b6 return new token and refreshToken on password change. v0.2.7 \u00b6 allow login on register, returning token and refresh token. v0.2.6 \u00b6 review error fields in some mutations. v0.2.5 \u00b6 update apps config. nothing new. v0.2.4 \u00b6 add mutation to remove secondary email. v0.2.3 \u00b6 user status is created on signal. v0.2.2 \u00b6 fix typo in setup. nothing new. v0.2.1 \u00b6 fix readme on pypi. nothing new. v0.2.0 \u00b6 minor bug fixes. add user status model to track if user is archived, verified and secondary email. add new mutations to handle secondary email. allow login with secondary email. v0.1 \u00b6 0.1.11 \u00b6 Fix minor bugs. 0.1.10 \u00b6 Fix minor bugs. 0.1.9 \u00b6 Rename settings params. 0.1.8 \u00b6 Fix typo in settings. 0.1.7 \u00b6 No changes (testing release on Travis). 0.1.6 \u00b6 Support for Django >= 2.1 0.1.5 \u00b6 Revoke refresh tokens when archiving user. 0.1.4 \u00b6 Allow to revoke refresh tokens on password change and reset. 0.1.3 \u00b6 Better settings api. 0.1.2 \u00b6 Update setup.py. 0.1.1 \u00b6 Add initial README file! 0.1.0 \u00b6 Hello world!","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v0360","text":"","title":"v0.3.6.0"},{"location":"changelog/#deprecations","text":"Removed secondary email support.","title":"Deprecations:"},{"location":"changelog/#new-features","text":"","title":"New features"},{"location":"changelog/#-mypy-support","text":"","title":"- mypy support"},{"location":"changelog/#v0351","text":"","title":"v0.3.5.1"},{"location":"changelog/#new-features_1","text":"Support for subscriptions, tested with channels integrations.","title":"New features"},{"location":"changelog/#v0350","text":"","title":"v0.3.5.0"},{"location":"changelog/#new-features_2","text":"new setting GqlAuthSettings.JWT_TOKEN_FINDER for finding the token from Info object, useful for integrations that provide custom info object.","title":"New features:"},{"location":"changelog/#v0342","text":"","title":"v0.3.4.2"},{"location":"changelog/#deprecations_1","text":"users query was removed due to security concerns. If you want it implement it yourself and make sure to use the appropriate auth measures SomeField.afield is removed, and you can use now just SomeField.field for async/sync. decorators are deprecated, and you should use directives from now on.","title":"Deprecations:"},{"location":"changelog/#new-features_3","text":"","title":"New features:"},{"location":"changelog/#v0341","text":"","title":"v0.3.4.1"},{"location":"changelog/#deprecations_2","text":"LOGIN_REQUIRED_FIELDS and LOGIN_OPTIONAL_FIELDS are deprecated in favor of LOGIN_FIELDS . From now on you should pass StrawberryField instance to LOGIN_FIELDS and it is absolutely your responsibility what would be optional/required. REGISTER_MUTATION_FIELDS_OPTIONAL is deprecated in favor of REGISTER_MUTATION_FIELDS . UPDATE_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS are also taking StrawberryField instances from now on.","title":"deprecations"},{"location":"changelog/#v0340","text":"New features serve Captcha over static files. New setting introduced, CAPTCHA_SAVE_IMAGE: bool = False .","title":"v0.3.4.0"},{"location":"changelog/#v0332","text":"New features Any fields that are in either UPDATE_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS , REGISTER_MUTATION_FIELDS_OPTIONAL And the pk field of the model. Will be inserted to UserType and will be in user queries. Doc strings in gqlquth_settings object Bug fixed Issue #45, #42 LOGIN_REQUIRED_FIELDS is now supported,\\ These fields would be used to authenticate with SD-jwt authenticate function. This function will call each of our AUTHENTICATION_BACKENDS , And will return the user from one of them unless PermissionDenied was raised. REGISTER_MUTATION_FIELDS is now supported,\\ Fields that will be registered there will be required by Register mutation Development Notes Added new marker for pytest, default_user this is the user defined in the default settings, And the custom user is in settings_b.py with no email field.","title":"v0.3.3.2"},{"location":"changelog/#v0331-pre-release","text":"New features async support using ASGI, the resolvers are still sync because of django's ORM - API changes Previously, following the graphene version, we did i.e token_auth = relay.ObtainJSONWebToken.Field ,\\ In order to respect pep8 (since it is a function)\\ and Strawberry style we changed it to token_auth = relay.ObtainJSONWebToken.field . Renamed Cap.Field to Captcha.field . Deprecations Removed setting ASYNC_EMAIL_TASK, (originally this was a celery task). Development Notes Major refactoring of how the test work: removed all the dicts that was flying around and used dataclasses. added async tests for all tests. no longer using request factory, now using test client as it emulates more real life environment.","title":"v0.3.3.1 - pre-release"},{"location":"changelog/#v0316","text":"Nothing new, adding PyJWT<=2.0.0 to requirements","title":"v0.3.16"},{"location":"changelog/#v0315","text":"Emit user_verified signal on password reset (thanks to @imsheldon )","title":"v0.3.15"},{"location":"changelog/#v0314","text":"Add passwordless registration (thanks to @joshuachinemezu ) Add user_verified and user_registered signals (thanks to @mnieber ) Verify user in password reset mutation (thanks to capaci )","title":"v0.3.14"},{"location":"changelog/#v0313","text":"Add EMAIL_TEMPLATE_VARIABLES setting (thanks to capaci )","title":"v0.3.13"},{"location":"changelog/#v0312","text":"Add CUSTOM_ERROR_TYPE setting (thanks to boolangery )","title":"v0.3.12"},{"location":"changelog/#v0311","text":"Add select_related to UserNode to limit db queries (thanks to maxpeterson )","title":"v0.3.11"},{"location":"changelog/#v0310","text":"Pseudo async email support (thanks to bzhr and me )","title":"v0.3.10"},{"location":"changelog/#v039","text":"Prevents that UserNode is registered globally for the User type (thanks to panosangelopoulos )","title":"v0.3.9"},{"location":"changelog/#v038","text":"Add request and timestamp to email templates (thanks to yanivtoledano )","title":"v0.3.8"},{"location":"changelog/#v037","text":"Add template variables to email subjects.","title":"v0.3.7"},{"location":"changelog/#v036","text":"Replace RemovedInDjango40Warning ugettext with gettext (thanks to ulgens )","title":"v0.3.6"},{"location":"changelog/#v035","text":"Added MeQuery (thanks to pors ).","title":"v0.3.5"},{"location":"changelog/#v034","text":"Renamed from ErrorType to ExpectedErrorType , preventing clash with a strawberry.django type with same name..","title":"v0.3.4"},{"location":"changelog/#v033","text":"Fixed bug when performing login in PasswordChangeMixin (thanks to panosangelopoulos ).","title":"v0.3.3"},{"location":"changelog/#v032","text":"Fixed typo in error code/message for expired_token (thanks to yanivtoledano ).","title":"v0.3.2"},{"location":"changelog/#v031","text":"add pk to UserNode.","title":"v0.3.1"},{"location":"changelog/#v030","text":"release beta.","title":"v0.3.0"},{"location":"changelog/#v02","text":"","title":"v0.2"},{"location":"changelog/#v028","text":"return new token and refreshToken on password change.","title":"v0.2.8"},{"location":"changelog/#v027","text":"allow login on register, returning token and refresh token.","title":"v0.2.7"},{"location":"changelog/#v026","text":"review error fields in some mutations.","title":"v0.2.6"},{"location":"changelog/#v025","text":"update apps config. nothing new.","title":"v0.2.5"},{"location":"changelog/#v024","text":"add mutation to remove secondary email.","title":"v0.2.4"},{"location":"changelog/#v023","text":"user status is created on signal.","title":"v0.2.3"},{"location":"changelog/#v022","text":"fix typo in setup. nothing new.","title":"v0.2.2"},{"location":"changelog/#v021","text":"fix readme on pypi. nothing new.","title":"v0.2.1"},{"location":"changelog/#v020","text":"minor bug fixes. add user status model to track if user is archived, verified and secondary email. add new mutations to handle secondary email. allow login with secondary email.","title":"v0.2.0"},{"location":"changelog/#v01","text":"","title":"v0.1"},{"location":"changelog/#0111","text":"Fix minor bugs.","title":"0.1.11"},{"location":"changelog/#0110","text":"Fix minor bugs.","title":"0.1.10"},{"location":"changelog/#019","text":"Rename settings params.","title":"0.1.9"},{"location":"changelog/#018","text":"Fix typo in settings.","title":"0.1.8"},{"location":"changelog/#017","text":"No changes (testing release on Travis).","title":"0.1.7"},{"location":"changelog/#016","text":"Support for Django >= 2.1","title":"0.1.6"},{"location":"changelog/#015","text":"Revoke refresh tokens when archiving user.","title":"0.1.5"},{"location":"changelog/#014","text":"Allow to revoke refresh tokens on password change and reset.","title":"0.1.4"},{"location":"changelog/#013","text":"Better settings api.","title":"0.1.3"},{"location":"changelog/#012","text":"Update setup.py.","title":"0.1.2"},{"location":"changelog/#011","text":"Add initial README file!","title":"0.1.1"},{"location":"changelog/#010","text":"Hello world!","title":"0.1.0"},{"location":"contributing/","text":"Contributing \u00b6 Thanks for helping improve Django GraphQL Auth! All kinds of contributions are welcome: Bug fixes Documentation improvements New features Refactoring Fix some typo Write more tests Getting started \u00b6 If you have a specific contribution in mind, be sure to check the issues and projects in progress - someone could already be working on something similar and you can help out. Project setup \u00b6 After cloning this repo, ensure dependencies are installed by running: make dev-setup and pip install tox Running tests \u00b6 After developing, you can run tests with: # python=3.7 and django=3.0 make test You can specify versions, for the full list see the tox.ini file. # python=3.6 and django=2.2 make test p = 36 d = 22 Test directly with tox: tox Single file test shortcut: # run only tests in tests/test_register.py make test-file f = register For live testing on a django project, you can use the testproject. Create a different virtualenv, install the dependencies again and run: cd testproject make install-local v = <CURRENT VERSION IN gqlauth.__init__> Opening Pull Requests \u00b6 Please fork the project and open a pull request against the master branch. This will trigger a series of tests and lint checks. We advise that you format and run lint locally before doing this to save time: make format make lint Documentation \u00b6 The documentation is generated using the excellent MkDocs with material theme . The documentation dependencies are installed by running: pip install -r docs/requirements.txt Then to produce a HTML version of the documentation, for live editing: make serve It will run the docs/pre_build.py script before building the docs.","title":"Contributing"},{"location":"contributing/#contributing","text":"Thanks for helping improve Django GraphQL Auth! All kinds of contributions are welcome: Bug fixes Documentation improvements New features Refactoring Fix some typo Write more tests","title":"Contributing"},{"location":"contributing/#getting-started","text":"If you have a specific contribution in mind, be sure to check the issues and projects in progress - someone could already be working on something similar and you can help out.","title":"Getting started"},{"location":"contributing/#project-setup","text":"After cloning this repo, ensure dependencies are installed by running: make dev-setup and pip install tox","title":"Project setup"},{"location":"contributing/#running-tests","text":"After developing, you can run tests with: # python=3.7 and django=3.0 make test You can specify versions, for the full list see the tox.ini file. # python=3.6 and django=2.2 make test p = 36 d = 22 Test directly with tox: tox Single file test shortcut: # run only tests in tests/test_register.py make test-file f = register For live testing on a django project, you can use the testproject. Create a different virtualenv, install the dependencies again and run: cd testproject make install-local v = <CURRENT VERSION IN gqlauth.__init__>","title":"Running tests"},{"location":"contributing/#opening-pull-requests","text":"Please fork the project and open a pull request against the master branch. This will trigger a series of tests and lint checks. We advise that you format and run lint locally before doing this to save time: make format make lint","title":"Opening Pull Requests"},{"location":"contributing/#documentation","text":"The documentation is generated using the excellent MkDocs with material theme . The documentation dependencies are installed by running: pip install -r docs/requirements.txt Then to produce a HTML version of the documentation, for live editing: make serve It will run the docs/pre_build.py script before building the docs.","title":"Documentation"},{"location":"contributors/","text":"Contributors \u00b6 @pedrobern @nrbnlulu @yanivtoledano @ulgens @panosangelopoulos @pors @bzhr @maxpeterson @boolangery @capaci @mnieber @joshuachinemezu @imsheldon","title":"Contributors"},{"location":"contributors/#contributors","text":"@pedrobern @nrbnlulu @yanivtoledano @ulgens @panosangelopoulos @pors @bzhr @maxpeterson @boolangery @capaci @mnieber @joshuachinemezu @imsheldon","title":"Contributors"},{"location":"directives/","text":"(TBD) \u00b6 We offer directives to support Authorization and permissions checks with a nice error messages You can check the source code for more information at the moment.","title":"directives"},{"location":"directives/#tbd","text":"We offer directives to support Authorization and permissions checks with a nice error messages You can check the source code for more information at the moment.","title":"(TBD)"},{"location":"overriding-email-templates/","text":"Overriding Email Templates \u00b6 The default email templates are just examples, you probably want to customize it. Update your settings: \u00b6 # settings.py import os TEMPLATES = [ { #... \"DIRS\" : [ os . path . join ( BASE_DIR , \"templates\" )], # ... }, ] File and folder sctructure \u00b6 Create the following folder and files structure: - project_name/ - project_name/ - templates/ email/ activation_email.html activation_subject.txt password_reset_email.html password_reset_subject.txt db.sqlite3 manage.py This is the minimum. Check the email templates settings , you can create custom templates for: account activation resend account activation email password reset email Email variables \u00b6 Both subject and email templates receive the following variables: user token \u2192 account activation / password reset port site_name \u2192 from django sites framework (optional) domain \u2192 from django sites framework (optional) protocol path \u2192 defined in settings (some frontend path) request timestamp custom variables defined using EMAIL_TEMPLATE_VARIABLES setting \u2192 defined in settings Writing the templates \u00b6 Write your templates like this: <!-- activation_email.html --> < h3 > {{ site_name }} </ h3 > < p > Hello \\{{ user.username }}! </ p > < p > Please activate your account on the link: </ p > < p > {{ protocol }}://{{ domain }}/{{ path }}/{{ token }} </ p > Provide only the html template. It will be converted to text later.","title":"Overriding email templates"},{"location":"overriding-email-templates/#overriding-email-templates","text":"The default email templates are just examples, you probably want to customize it.","title":"Overriding Email Templates"},{"location":"overriding-email-templates/#update-your-settings","text":"# settings.py import os TEMPLATES = [ { #... \"DIRS\" : [ os . path . join ( BASE_DIR , \"templates\" )], # ... }, ]","title":"Update your settings:"},{"location":"overriding-email-templates/#file-and-folder-sctructure","text":"Create the following folder and files structure: - project_name/ - project_name/ - templates/ email/ activation_email.html activation_subject.txt password_reset_email.html password_reset_subject.txt db.sqlite3 manage.py This is the minimum. Check the email templates settings , you can create custom templates for: account activation resend account activation email password reset email","title":"File and folder sctructure"},{"location":"overriding-email-templates/#email-variables","text":"Both subject and email templates receive the following variables: user token \u2192 account activation / password reset port site_name \u2192 from django sites framework (optional) domain \u2192 from django sites framework (optional) protocol path \u2192 defined in settings (some frontend path) request timestamp custom variables defined using EMAIL_TEMPLATE_VARIABLES setting \u2192 defined in settings","title":"Email variables"},{"location":"overriding-email-templates/#writing-the-templates","text":"Write your templates like this: <!-- activation_email.html --> < h3 > {{ site_name }} </ h3 > < p > Hello \\{{ user.username }}! </ p > < p > Please activate your account on the link: </ p > < p > {{ protocol }}://{{ domain }}/{{ path }}/{{ token }} </ p > Provide only the html template. It will be converted to text later.","title":"Writing the templates"},{"location":"relay/","text":"Relay \u00b6 Import mutations from the relay module: import strawberry from gqlauth.user import relay @strawberry . type class AuthMutation : register = relay . Register . field Note that relay is not supported for queries yet. \u00b6","title":"Relay"},{"location":"relay/#relay","text":"Import mutations from the relay module: import strawberry from gqlauth.user import relay @strawberry . type class AuthMutation : register = relay . Register . field","title":"Relay"},{"location":"relay/#note-that-relay-is-not-supported-for-queries-yet","text":"","title":"Note that relay is not supported for queries yet."},{"location":"settings/","text":"auto generated using pydoc_markdown GqlAuthSettings \u00b6 @dataclass class GqlAuthSettings () ALLOW_LOGIN_NOT_VERIFIED \u00b6 LOGIN_FIELDS \u00b6 These fields would be used to authenticate with SD-jwt authenticate function. This function will call each of our AUTHENTICATION_BACKENDS , And will return the user from one of them unless PermissionDenied was raised. You can pass any fields that would be accepted by your backends. Note that password field is mandatory and cannot be removed. LOGIN_REQUIRE_CAPTCHA \u00b6 whether login will require captcha verification. REGISTER_MUTATION_FIELDS \u00b6 fields on register, plus password1 and password2, can be a dict like UPDATE_MUTATION_fieldS setting REGISTER_REQUIRE_CAPTCHA \u00b6 whether register will require captcha verification. CAPTCHA_EXPIRATION_DELTA \u00b6 captcha stuff captcha expiration delta. CAPTCHA_MAX_RETRIES \u00b6 max number of attempts for one captcha. CAPTCHA_TEXT_FACTORY \u00b6 A callable with no arguments that returns a string. This will be used to generate the captcha image. CAPTCHA_TEXT_VALIDATOR \u00b6 A callable that will receive the original string vs user input and returns a boolean. FORCE_SHOW_CAPTCHA \u00b6 Whether to show the captcha image after it has been created for debugging purposes. CAPTCHA_SAVE_IMAGE \u00b6 if True, an png representation of the captcha will be saved under MEDIA_ROOT/captcha/ / .png UPDATE_MUTATION_FIELDS \u00b6 fields on update account mutation. ALLOW_DELETE_ACCOUNT \u00b6 If True, DeleteAcount mutation will permanently delete the user. ALLOW_PASSWORDLESS_REGISTRATION \u00b6 Whether to allow registration with no password JWT_SECRET_KEY \u00b6 key used to sign the JWT token. JWT_ALGORITHM \u00b6 Algorithm used for signing the token. JWT_TIME_FORMAT \u00b6 A valid 'strftime' string that will be used to encode the token payload. JWT_PAYLOAD_HANDLER \u00b6 A custom function to generate the token datatype, its up to you to encode the token. JWT_PAYLOAD_PK \u00b6 field that will be used to generate the token from a user instance and retrieve user based on the decoded token. This filed must be unique in the database JWT_TOKEN_FINDER \u00b6 A hook called by GqlAuthRootField to find the token, remember to strip the \"JWT \" prefix if you override this. JWT_EXPIRATION_DELTA \u00b6 Timedelta added to utcnow() to set the expiration time. When this ends you will have to create a new token by logging in or using the refresh token. JWT_LONG_RUNNING_REFRESH_TOKEN \u00b6 Whether to enable refresh tokens to be used as an alternative to login every time the token is expired. JWT_REFRESH_TOKEN_N_BYTES \u00b6 Number of bytes for long running refresh token. JWT_REFRESH_EXPIRATION_DELTA \u00b6 Refresh token expiration time delta.","title":"Settings"},{"location":"settings/#gqlauthsettings","text":"@dataclass class GqlAuthSettings ()","title":"GqlAuthSettings"},{"location":"settings/#allow_login_not_verified","text":"","title":"ALLOW_LOGIN_NOT_VERIFIED"},{"location":"settings/#login_fields","text":"These fields would be used to authenticate with SD-jwt authenticate function. This function will call each of our AUTHENTICATION_BACKENDS , And will return the user from one of them unless PermissionDenied was raised. You can pass any fields that would be accepted by your backends. Note that password field is mandatory and cannot be removed.","title":"LOGIN_FIELDS"},{"location":"settings/#login_require_captcha","text":"whether login will require captcha verification.","title":"LOGIN_REQUIRE_CAPTCHA"},{"location":"settings/#register_mutation_fields","text":"fields on register, plus password1 and password2, can be a dict like UPDATE_MUTATION_fieldS setting","title":"REGISTER_MUTATION_FIELDS"},{"location":"settings/#register_require_captcha","text":"whether register will require captcha verification.","title":"REGISTER_REQUIRE_CAPTCHA"},{"location":"settings/#captcha_expiration_delta","text":"captcha stuff captcha expiration delta.","title":"CAPTCHA_EXPIRATION_DELTA"},{"location":"settings/#captcha_max_retries","text":"max number of attempts for one captcha.","title":"CAPTCHA_MAX_RETRIES"},{"location":"settings/#captcha_text_factory","text":"A callable with no arguments that returns a string. This will be used to generate the captcha image.","title":"CAPTCHA_TEXT_FACTORY"},{"location":"settings/#captcha_text_validator","text":"A callable that will receive the original string vs user input and returns a boolean.","title":"CAPTCHA_TEXT_VALIDATOR"},{"location":"settings/#force_show_captcha","text":"Whether to show the captcha image after it has been created for debugging purposes.","title":"FORCE_SHOW_CAPTCHA"},{"location":"settings/#captcha_save_image","text":"if True, an png representation of the captcha will be saved under MEDIA_ROOT/captcha/ / .png","title":"CAPTCHA_SAVE_IMAGE"},{"location":"settings/#update_mutation_fields","text":"fields on update account mutation.","title":"UPDATE_MUTATION_FIELDS"},{"location":"settings/#allow_delete_account","text":"If True, DeleteAcount mutation will permanently delete the user.","title":"ALLOW_DELETE_ACCOUNT"},{"location":"settings/#allow_passwordless_registration","text":"Whether to allow registration with no password","title":"ALLOW_PASSWORDLESS_REGISTRATION"},{"location":"settings/#jwt_secret_key","text":"key used to sign the JWT token.","title":"JWT_SECRET_KEY"},{"location":"settings/#jwt_algorithm","text":"Algorithm used for signing the token.","title":"JWT_ALGORITHM"},{"location":"settings/#jwt_time_format","text":"A valid 'strftime' string that will be used to encode the token payload.","title":"JWT_TIME_FORMAT"},{"location":"settings/#jwt_payload_handler","text":"A custom function to generate the token datatype, its up to you to encode the token.","title":"JWT_PAYLOAD_HANDLER"},{"location":"settings/#jwt_payload_pk","text":"field that will be used to generate the token from a user instance and retrieve user based on the decoded token. This filed must be unique in the database","title":"JWT_PAYLOAD_PK"},{"location":"settings/#jwt_token_finder","text":"A hook called by GqlAuthRootField to find the token, remember to strip the \"JWT \" prefix if you override this.","title":"JWT_TOKEN_FINDER"},{"location":"settings/#jwt_expiration_delta","text":"Timedelta added to utcnow() to set the expiration time. When this ends you will have to create a new token by logging in or using the refresh token.","title":"JWT_EXPIRATION_DELTA"},{"location":"settings/#jwt_long_running_refresh_token","text":"Whether to enable refresh tokens to be used as an alternative to login every time the token is expired.","title":"JWT_LONG_RUNNING_REFRESH_TOKEN"},{"location":"settings/#jwt_refresh_token_n_bytes","text":"Number of bytes for long running refresh token.","title":"JWT_REFRESH_TOKEN_N_BYTES"},{"location":"settings/#jwt_refresh_expiration_delta","text":"Refresh token expiration time delta.","title":"JWT_REFRESH_EXPIRATION_DELTA"},{"location":"tutorial/","text":"What to expect \u00b6 Fully functional API to handle user account Both graphQL and Relay versions Setup with custom user model 20 to 30 minutes Final code on github . Requirements \u00b6 Python: >= 3.8 Django: >= 3.2 Basic knowledge in Strawberry Start a new Django Project \u00b6 It's recommended to use virtual env wrapper or virtualenv to create your project inside an isolated python environment. We will use the first. Create the virtual env \u00b6 python -m venv venv cd venv/bin source activate.sh Create the Django Project \u00b6 First install django: python -m pip install django Then, create the new project: django-admin startproject quickstart cd quickstart Create the custom user model \u00b6 Changing to a custom user model mid-project is significantly more difficult. So let's start by adding it now. Run the following: python manage.py startapp users Then, create the custom user model: # users/models.py from django.contrib.auth.models import AbstractUser class CustomUser ( AbstractUser ): email = models . EmailField ( blank = False , max_length = 254 , verbose_name = \"email address\" ) USERNAME_FIELD = \"username\" # e.g: \"username\", \"email\" EMAIL_FIELD = \"email\" # e.g: \"email\", \"primary_email\" Add it to the settings: # quickstart/settings.py INSTALLED_APPS = [ # ... 'users' ] AUTH_USER_MODEL = 'users.CustomUser' Finally, migrate: python manage.py makemigrations python manage.py migrate You can customize the mutations to match your custom user model fields, see the dynamic-fields settings . Install strawberry-django-auth \u00b6 # quickstart.settings.py from gqlauth.settings_type import GqlAuthSettings INSTALLED_APPS = [ # ... 'django.contrib.staticfiles' , # Required for GraphiQL \"strawberry_django\" \"gqlauth\" , ] MIDDLEWARE = [ # ... 'django.contrib.auth.middleware.AuthenticationMiddleware' , # ... ] AUTHENTICATION_BACKENDS = [ \"django.contrib.auth.backends.ModelBackend\" , ] We will disable captcha validation for now, just for ease of setup. GQL_AUTH = GqlAuthSettings ( LOGIN_REQUIRE_CAPTCHA = False , REGISTER_REQUIRE_CAPTCHA = False , ) And make sure your templates configuration has the following: TEMPLATES = [ { # ... 'APP_DIRS' : True , }, ] Run: python -m manage migrate Create the schema \u00b6 Create a file called schema.py next to your settings.py Add the following to code: # yourapp/users/schema.py import strawberry from gqlauth.user.queries import UserQueries from gqlauth.core.field_ import field from gqlauth.core.types_ import GQLAuthError from gqlauth.core.directives import TokenRequired from typing import Union Default Relay from gqlauth.user import arg_mutations as mutations from gqlauth.user import relay as mutations @strawberry . type class MyAuthorizedQueries ( UserQueries ): # add your queries that require authorization here. @strawberry . field def secured_string ( self ) -> str : return \"secure\" you can choose what fields to include like this import strawberry from gqlauth.user.queries import UserQueries , UserType from django.contrib.auth import get_user_model @strawberry . django . type ( model = get_user_model ()) class MyQueries : me : UserType = UserQueries . me public : UserType = UserQueries . public_user # etc... TokenRequired TokenRequired directive is responsible for validating the token you have in the headers and injecting the user instance inside info.context.user . Any field that requires to interaction with the user (i.e check permissions) must be present beneath this directive, otherwise the user is not accessible. This is the case for both mutations, queries and subscriptions. You must also use our version of strawberry.field because normally directives doesn't do anything. @strawberry . type class Query : @field ( directives = [ TokenRequired ()]) def auth_entry ( self ) -> Union [ GQLAuthError , MyAuthorizedQueries ]: return MyAuthorizedQueries () Warning Even though you can choose what mutations to include, you must include mutations that requires authentication under or in a field with TokenRequired directive, otherwise you will just get graphql errors instead of nice outputs. @strawberry . type class AuthMutation : # include here your mutations that interact with a user object from a token. verify_token = mutations . VerifyToken . field update_account = mutations . UpdateAccount . field archive_account = mutations . ArchiveAccount . field delete_account = mutations . DeleteAccount . field password_change = mutations . PasswordChange . field swap_emails = mutations . SwapEmails . field @strawberry . type class Mutation : @field ( directives = [ TokenRequired ()]) def auth_entry ( self ) -> Union [ AuthMutation , GQLAuthError ]: return AuthOutput ( node = AuthMutation ()) # these are mutation that does not require authentication. captcha = Captcha . field token_auth = mutations . ObtainJSONWebToken . field register = mutations . Register . field verify_account = mutations . VerifyAccount . field resend_activation_email = mutations . ResendActivationEmail . field send_password_reset_email = mutations . SendPasswordResetEmail . field password_reset = mutations . PasswordReset . field password_set = mutations . PasswordSet . field refresh_token = mutations . RefreshToken . field revoke_token = mutations . RevokeToken . field verify_secondary_email = mutations . VerifySecondaryEmail . field schema = strawberry . Schema ( query = Query , mutation = Mutation ) Load fixtures \u00b6 Before starting to query, let's load some users on the database. Create a new file called users.json in the same directory as manage.py with the following: Have a look on the fixtures, note that we are creating 4 users and 3 UserStatus . When creating a user, we create a relating UserStatus by default on post_save signal with the following fields: verified = False archived = False You can access it on any user: user.status. [ verified | archived ] [ { \"model\" : \"users.CustomUser\" , \"pk\" : 1 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user1\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user1@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 2 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user2\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user2@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 2 , \"fields\" : { \"user\" : 2 , \"verified\" : true , \"archived\" : false , } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 3 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user3\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user3@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 3 , \"fields\" : { \"user\" : 3 , \"verified\" : true , \"archived\" : true , } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 4 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user4\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user4@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 4 , \"fields\" : { \"user\" : 4 , \"verified\" : true , \"archived\" : false } } ] run: python -m manage loaddata users.json Making your first query \u00b6 Start the dev server: python manage.py runserver Open your browser: http://127.0.0.1:8000/graphql First let's log-in: \u00b6 Setup Email Backend \u00b6 The default configuration is to send activation email when registering users, you can set it to False on your settings , but you still need an Email Backend to password reset. The quickest solution for development is to set up a Console Email Backend , simply add the following to your settings.py . EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' Now all emails are sent to the standard output, instead of an actual email and we are ready to continue this guide. Let's try to register a new user: \u00b6 Too weak password gql relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", ) { success, errors, } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : false , \"errors\" : { \"password2\" : [ { \"message\" : \"This password is too short. It must contain at least 8 characters.\" , \"code\" : \"password_too_short\" }, { \"message\" : \"This password is too common.\" , \"code\" : \"password_too_common\" }, { \"message\" : \"This password is entirely numeric.\" , \"code\" : \"password_entirely_numeric\" } ] } } } } Something went wrong! Now you know the response format that you can expect of all mutations. Let's try again: successful registration arg_mutation relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", ) { success, errors, success } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : true , \"errors\" : null } } } There is actually a new user, it is possible to log in (you can change it on the settings ), but it is not verified yet. Save the id of the new user, so we can query it later. Go to your console and note the email that has been sent. Should be two outputs, html and plain text formats. Save the token from the url, something like this: eyJ1c2VybmFtZSI6Im5ld191c2VyIiwiYWN0aW9uIjoiYWN0aXZhdGlvbiJ9:1isoSr:CDwK_fjBSxWj3adC-X16wqzv-Mw Verify the new user. \u00b6 search your schema for verify_account : should look like this: Now let's try to verify the account: Gql arg_mutation relay result mutation { verifyAccount(token: \"YOUR TOKEN HERE\") { success, errors } } mutation { verifyAccount ( input : { token : \"<YOUR TOKEN HERE>\" } ) { success , errors } } { \"data\" : { \"verifyAccount\" : { \"success\" : true , \"errors\" : null } } } Login \u00b6 search your schema for tokenAuth : should look like this: Gql arg_mutation relay response mutation { tokenAuth(username: \"new_user\", password: \"SuperSecureP@sw0rd\") { success errors token { payload { origIat exp } token } user { isActive username email status { verified } } } } mutation { tokenAuth(input: {username: \"new_user\", password: \"SuperSecureP@sw0rd\"}) { success errors token { payload { origIat exp } token } user { isActive username email status { verified } } } } { \"data\" : { \"tokenAuth\" : { \"success\" : true , \"errors\" : null , \"token\" : { \"payload\" : { \"origIat\" : \"2022-09-18T14:56:33.829961\" , \"exp\" : \"2022-09-18T15:01:33.829961\" }, \"token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXlsb2FkIjoie1xuIFwiZXhwXCI6IFwiMjAyMi0wOS0xOFQxNTowMTozMy44Mjk5NjFcIixcbiBcIm9yaWdJYXRcIjogXCIyMDIyLTA5LTE4VDE0OjU2OjMzLjgyOTk2MVwiLFxuIFwidXNlcm5hbWVcIjogXCJuZXdfdXNlclwiXG59In0.2qSD_203UCa4EmtiDz-YtbO59ETaLfLGj7R_6c2197Y\" }, \"user\" : { \"isActive\" : true , \"username\" : \"new_user\" , \"email\" : \"new_user@email.com\" , \"status\" : { \"verified\" : true } } } } } Save this token , we are going to use it in the request headers. MeQuery \u00b6 With MeQuery you can retrieve data for the currently authenticated user: No headers supplied will give nice error message query response query MyQuery { authEntry { ... on GQLAuthError { code message } ... on MyAuthorizedQueries{ me { username verified } } } } { \"data\" : { \"authEntry\" : { \"code\" : \"INVALID_TOKEN\" , \"message\" : \"Invalid token.\" } } } With the token from last mutation, we can access the data. Add The token in the Headers section in GraphiQL query response query MyQuery { authEntry { ... on GQLAuthError { code message } ... on MyAuthorizedQueries{ me { username verified } } } } { \"data\" : { \"authEntry\" : { \"me\" : { \"username\" : \"new_user\" , \"verified\" : true } } } } If it fails because of the token (in case you took some time, and it has expired), make the login again and get a new token. Next steps \u00b6 explore all the mutations. Navigate through the GraphiQL Documentation Explorer. Change the settings . Explore the api . check our directives . make sure you are familiar with our captcha system. Override email templates .","title":"Tutorial"},{"location":"tutorial/#what-to-expect","text":"Fully functional API to handle user account Both graphQL and Relay versions Setup with custom user model 20 to 30 minutes Final code on github .","title":"What to expect"},{"location":"tutorial/#requirements","text":"Python: >= 3.8 Django: >= 3.2 Basic knowledge in Strawberry","title":"Requirements"},{"location":"tutorial/#start-a-new-django-project","text":"It's recommended to use virtual env wrapper or virtualenv to create your project inside an isolated python environment. We will use the first.","title":"Start a new Django Project"},{"location":"tutorial/#create-the-virtual-env","text":"python -m venv venv cd venv/bin source activate.sh","title":"Create the virtual env"},{"location":"tutorial/#create-the-django-project","text":"First install django: python -m pip install django Then, create the new project: django-admin startproject quickstart cd quickstart","title":"Create the Django Project"},{"location":"tutorial/#create-the-custom-user-model","text":"Changing to a custom user model mid-project is significantly more difficult. So let's start by adding it now. Run the following: python manage.py startapp users Then, create the custom user model: # users/models.py from django.contrib.auth.models import AbstractUser class CustomUser ( AbstractUser ): email = models . EmailField ( blank = False , max_length = 254 , verbose_name = \"email address\" ) USERNAME_FIELD = \"username\" # e.g: \"username\", \"email\" EMAIL_FIELD = \"email\" # e.g: \"email\", \"primary_email\" Add it to the settings: # quickstart/settings.py INSTALLED_APPS = [ # ... 'users' ] AUTH_USER_MODEL = 'users.CustomUser' Finally, migrate: python manage.py makemigrations python manage.py migrate You can customize the mutations to match your custom user model fields, see the dynamic-fields settings .","title":"Create the custom user model"},{"location":"tutorial/#install-strawberry-django-auth","text":"# quickstart.settings.py from gqlauth.settings_type import GqlAuthSettings INSTALLED_APPS = [ # ... 'django.contrib.staticfiles' , # Required for GraphiQL \"strawberry_django\" \"gqlauth\" , ] MIDDLEWARE = [ # ... 'django.contrib.auth.middleware.AuthenticationMiddleware' , # ... ] AUTHENTICATION_BACKENDS = [ \"django.contrib.auth.backends.ModelBackend\" , ] We will disable captcha validation for now, just for ease of setup. GQL_AUTH = GqlAuthSettings ( LOGIN_REQUIRE_CAPTCHA = False , REGISTER_REQUIRE_CAPTCHA = False , ) And make sure your templates configuration has the following: TEMPLATES = [ { # ... 'APP_DIRS' : True , }, ] Run: python -m manage migrate","title":"Install strawberry-django-auth"},{"location":"tutorial/#create-the-schema","text":"Create a file called schema.py next to your settings.py Add the following to code: # yourapp/users/schema.py import strawberry from gqlauth.user.queries import UserQueries from gqlauth.core.field_ import field from gqlauth.core.types_ import GQLAuthError from gqlauth.core.directives import TokenRequired from typing import Union Default Relay from gqlauth.user import arg_mutations as mutations from gqlauth.user import relay as mutations @strawberry . type class MyAuthorizedQueries ( UserQueries ): # add your queries that require authorization here. @strawberry . field def secured_string ( self ) -> str : return \"secure\" you can choose what fields to include like this import strawberry from gqlauth.user.queries import UserQueries , UserType from django.contrib.auth import get_user_model @strawberry . django . type ( model = get_user_model ()) class MyQueries : me : UserType = UserQueries . me public : UserType = UserQueries . public_user # etc... TokenRequired TokenRequired directive is responsible for validating the token you have in the headers and injecting the user instance inside info.context.user . Any field that requires to interaction with the user (i.e check permissions) must be present beneath this directive, otherwise the user is not accessible. This is the case for both mutations, queries and subscriptions. You must also use our version of strawberry.field because normally directives doesn't do anything. @strawberry . type class Query : @field ( directives = [ TokenRequired ()]) def auth_entry ( self ) -> Union [ GQLAuthError , MyAuthorizedQueries ]: return MyAuthorizedQueries () Warning Even though you can choose what mutations to include, you must include mutations that requires authentication under or in a field with TokenRequired directive, otherwise you will just get graphql errors instead of nice outputs. @strawberry . type class AuthMutation : # include here your mutations that interact with a user object from a token. verify_token = mutations . VerifyToken . field update_account = mutations . UpdateAccount . field archive_account = mutations . ArchiveAccount . field delete_account = mutations . DeleteAccount . field password_change = mutations . PasswordChange . field swap_emails = mutations . SwapEmails . field @strawberry . type class Mutation : @field ( directives = [ TokenRequired ()]) def auth_entry ( self ) -> Union [ AuthMutation , GQLAuthError ]: return AuthOutput ( node = AuthMutation ()) # these are mutation that does not require authentication. captcha = Captcha . field token_auth = mutations . ObtainJSONWebToken . field register = mutations . Register . field verify_account = mutations . VerifyAccount . field resend_activation_email = mutations . ResendActivationEmail . field send_password_reset_email = mutations . SendPasswordResetEmail . field password_reset = mutations . PasswordReset . field password_set = mutations . PasswordSet . field refresh_token = mutations . RefreshToken . field revoke_token = mutations . RevokeToken . field verify_secondary_email = mutations . VerifySecondaryEmail . field schema = strawberry . Schema ( query = Query , mutation = Mutation )","title":"Create the schema"},{"location":"tutorial/#load-fixtures","text":"Before starting to query, let's load some users on the database. Create a new file called users.json in the same directory as manage.py with the following: Have a look on the fixtures, note that we are creating 4 users and 3 UserStatus . When creating a user, we create a relating UserStatus by default on post_save signal with the following fields: verified = False archived = False You can access it on any user: user.status. [ verified | archived ] [ { \"model\" : \"users.CustomUser\" , \"pk\" : 1 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user1\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user1@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 2 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user2\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user2@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 2 , \"fields\" : { \"user\" : 2 , \"verified\" : true , \"archived\" : false , } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 3 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user3\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user3@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 3 , \"fields\" : { \"user\" : 3 , \"verified\" : true , \"archived\" : true , } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 4 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user4\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user4@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 4 , \"fields\" : { \"user\" : 4 , \"verified\" : true , \"archived\" : false } } ] run: python -m manage loaddata users.json","title":"Load fixtures"},{"location":"tutorial/#making-your-first-query","text":"Start the dev server: python manage.py runserver Open your browser: http://127.0.0.1:8000/graphql","title":"Making your first query"},{"location":"tutorial/#first-lets-log-in","text":"","title":"First let's log-in:"},{"location":"tutorial/#setup-email-backend","text":"The default configuration is to send activation email when registering users, you can set it to False on your settings , but you still need an Email Backend to password reset. The quickest solution for development is to set up a Console Email Backend , simply add the following to your settings.py . EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' Now all emails are sent to the standard output, instead of an actual email and we are ready to continue this guide.","title":"Setup Email Backend"},{"location":"tutorial/#lets-try-to-register-a-new-user","text":"Too weak password gql relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", ) { success, errors, } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : false , \"errors\" : { \"password2\" : [ { \"message\" : \"This password is too short. It must contain at least 8 characters.\" , \"code\" : \"password_too_short\" }, { \"message\" : \"This password is too common.\" , \"code\" : \"password_too_common\" }, { \"message\" : \"This password is entirely numeric.\" , \"code\" : \"password_entirely_numeric\" } ] } } } } Something went wrong! Now you know the response format that you can expect of all mutations. Let's try again: successful registration arg_mutation relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", ) { success, errors, success } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : true , \"errors\" : null } } } There is actually a new user, it is possible to log in (you can change it on the settings ), but it is not verified yet. Save the id of the new user, so we can query it later. Go to your console and note the email that has been sent. Should be two outputs, html and plain text formats. Save the token from the url, something like this: eyJ1c2VybmFtZSI6Im5ld191c2VyIiwiYWN0aW9uIjoiYWN0aXZhdGlvbiJ9:1isoSr:CDwK_fjBSxWj3adC-X16wqzv-Mw","title":"Let's try to register a new user:"},{"location":"tutorial/#verify-the-new-user","text":"search your schema for verify_account : should look like this: Now let's try to verify the account: Gql arg_mutation relay result mutation { verifyAccount(token: \"YOUR TOKEN HERE\") { success, errors } } mutation { verifyAccount ( input : { token : \"<YOUR TOKEN HERE>\" } ) { success , errors } } { \"data\" : { \"verifyAccount\" : { \"success\" : true , \"errors\" : null } } }","title":"Verify the new user."},{"location":"tutorial/#login","text":"search your schema for tokenAuth : should look like this: Gql arg_mutation relay response mutation { tokenAuth(username: \"new_user\", password: \"SuperSecureP@sw0rd\") { success errors token { payload { origIat exp } token } user { isActive username email status { verified } } } } mutation { tokenAuth(input: {username: \"new_user\", password: \"SuperSecureP@sw0rd\"}) { success errors token { payload { origIat exp } token } user { isActive username email status { verified } } } } { \"data\" : { \"tokenAuth\" : { \"success\" : true , \"errors\" : null , \"token\" : { \"payload\" : { \"origIat\" : \"2022-09-18T14:56:33.829961\" , \"exp\" : \"2022-09-18T15:01:33.829961\" }, \"token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXlsb2FkIjoie1xuIFwiZXhwXCI6IFwiMjAyMi0wOS0xOFQxNTowMTozMy44Mjk5NjFcIixcbiBcIm9yaWdJYXRcIjogXCIyMDIyLTA5LTE4VDE0OjU2OjMzLjgyOTk2MVwiLFxuIFwidXNlcm5hbWVcIjogXCJuZXdfdXNlclwiXG59In0.2qSD_203UCa4EmtiDz-YtbO59ETaLfLGj7R_6c2197Y\" }, \"user\" : { \"isActive\" : true , \"username\" : \"new_user\" , \"email\" : \"new_user@email.com\" , \"status\" : { \"verified\" : true } } } } } Save this token , we are going to use it in the request headers.","title":"Login"},{"location":"tutorial/#mequery","text":"With MeQuery you can retrieve data for the currently authenticated user: No headers supplied will give nice error message query response query MyQuery { authEntry { ... on GQLAuthError { code message } ... on MyAuthorizedQueries{ me { username verified } } } } { \"data\" : { \"authEntry\" : { \"code\" : \"INVALID_TOKEN\" , \"message\" : \"Invalid token.\" } } } With the token from last mutation, we can access the data. Add The token in the Headers section in GraphiQL query response query MyQuery { authEntry { ... on GQLAuthError { code message } ... on MyAuthorizedQueries{ me { username verified } } } } { \"data\" : { \"authEntry\" : { \"me\" : { \"username\" : \"new_user\" , \"verified\" : true } } } } If it fails because of the token (in case you took some time, and it has expired), make the login again and get a new token.","title":"MeQuery"},{"location":"tutorial/#next-steps","text":"explore all the mutations. Navigate through the GraphiQL Documentation Explorer. Change the settings . Explore the api . check our directives . make sure you are familiar with our captcha system. Override email templates .","title":"Next steps"}]}